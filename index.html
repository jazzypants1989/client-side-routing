<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tell me this isn't an SPA</title>
  </head>
  <style>
    body {
      position: absolute;
      overflow: hidden;
      background-color: #222;
      color: #fff;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    .dark {
      background-color: #222;
      color: #fff;
    }
    .dark a {
      color: #88f;
    }
    .purple {
      background-color: #88f;
      color: #ff0;
    }
    .purple a {
      color: #292;
    }
    .green {
      background-color: #0f0;
      color: #911;
    }
    .green a {
      color: #999;
    }

    #toggleTheme {
      position: absolute;
      top: 0;
      right: 0;
      margin: 1rem;
    }

    nav,
    footer {
      width: 100%;
      position: absolute;
      background-color: #222;
    }

    nav {
      top: 0;
      left: 0;
    }

    ul {
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      list-style: none;
    }

    main {
      width: 100%;
      overflow-y: auto;
      margin: 2rem auto;
      padding: 0;
    }

    img {
      aspect-ratio: 1/1;
      object-fit: contain;
      width: 100%;
      max-height: 50vh;
    }

    footer {
      bottom: 0;
    }
  </style>
  <body class="dark">
    <nav>
      <ul>
        <li>
          <a href="/" class="Link">Home</a>
        </li>
        <li>
          <a href="/about" class="Link">About</a>
        </li>
        <li>
          <a href="/products" class="Link">Products</a>
        </li>
        <li>
          <a href="/cart" class="Link">Cart </a>
          <span id="cart-count"></span>
          <span id="cart-total"></span>
        </li>
        <input aria-label="Search" type="text" placeholder="Search" />
      </ul>
    </nav>
    <main class="main"></main>
    <button id="toggleTheme">Toggle Theme</button>
    <footer>
      <a href="http://jazzypants.dev"> Â© 2023 Jovial Penguin, LLC.</a>
    </footer>
    <script async>
      // Define Global Variables. We have to be careful with these.
      const main = document.querySelector(".main") // Get the main element, which will be used to render the dynamic content
      const path = window.location.pathname // Get the current path from the URL entered in the browser
      const dynamicRoute = "product" // Define a dynamic route
      const search = document.querySelector("input") // Get the search input element
      const cartCount = document.querySelector("#cart-count") // Get the cart count element
      const cartAmount = document.querySelector("#cart-total") // Get the cart total element
      const themeCheck = localStorage.getItem("theme") // Get the theme from localStorage

      // Set the theme
      if (themeCheck === "dark") {
        document.body.classList.add("dark")
      } else if (themeCheck === "purple") {
        document.body.classList.add("purple")
      } else if (themeCheck === "green") {
        document.body.classList.add("green")
      }

      // Bring in the cart and initiate the DOM with the current cart state
      const cart = JSON.parse(localStorage.getItem("cart")) || {} // Get the cart from localStorage, or set it to an empty array if it doesn't exist.
      cartCount.innerText = Object.keys(cart).length // Set the cart count to the number of items in the cart
      cartAmount.innerText =
        "$" +
        Object.values(cart)
          .map((item) => item.product.price * item.quantity)
          .reduce((a, b) => a + b, 0)
          .toFixed(2) // Update the cart amount

      search.addEventListener("input", searchHandler) // Add an event listener to the search input element

      // "Database" of products
      const db = async () => {
        // This has to be async because we're using fetch
        console.log("Fetching data...")
        const response = await fetch("/db.json") // Fetch the data from the db.json file
        const data = await response.json() // Parse the data into a JSON object
        return data // Return the data
      }

      // All of our components
      const Home = () => {
        console.log("Home component is rendering")
        document.title = "Home" // Set the page title
        render(`
        <p>This is a totally real shop! See! That's a picture! Of a shop! Totally
      open.</p>
      <img src="/diana.avif" alt="Check us out" />
        `)
      } // Did I just write a functional component in vanilla JS? Yes. Yes I did.

      const About = () => {
        console.log("About component is rendering")
        document.title = "About"
        render(`
        <h1>About</h1>
      <p>
        This is a totally real shop that sells totally real products. It's not a
        demonstration of how client-side routing works. Noo! It's just a
        shop.
      </p>
        `)
      }

      const ProductComponent = (product) => {
        console.log("A product is rendering")
        return `
        <div class="product">
          <a href=/product/${product.id} class="Link">
            <img src="${product.image}" alt="${product.name}" />
          <h2>${product.name}</h2>
          </a>
          <p>${product.description}</p>
          <p>$${product.price}</p>
          <button class="add-to-cart" id="${product.id}">Add to cart</button>
        </div>
        `
      } // Oh look, we're passing props now. This is a functional component, after all.

      const ProductsPage = async () => {
        console.log("Products component is rendering")
        document.title = "Products"
        // Again, we don't know how long it will take for the "API" to respond, so we have to make this async so we can await the response
        const data = await db()
        const products = data.products
        const productsHTML = products.map(ProductComponent).join("") // Map over the products and render the ProductComponent for each one. Then join them all together into a string. (This is necessary because map returns an array, and we need a string to render HTML in the browser.)
        render(`<h1>Products</h1>${productsHTML}`)

        document.querySelectorAll(".add-to-cart").forEach((button) => {
          if (button.alreadyHasEventListener) return
          button.addEventListener("click", (e) => {
            const id = e.target.id
            const product = products.find(
              (product) => product.id === Number(id)
            )
            addToCart(product)
          })
          button.alreadyHasEventListener = true
        }) // This is a little tricky. We're adding an event listener to every button with the class "add-to-cart". When the button is clicked, we get the id from the button's id attribute, and then we find the product in our data that matches that id. Then we add that product to our cart. We had to wait until the products were rendered to the page before we could add the event listeners, because the buttons didn't exist until then. Also, we had to add a property to the button to make sure we didn't add multiple event listeners to the same button.
      }

      const ProductPage = async (id) => {
        console.log(
          `The ProductPage component is rendering product with ID: ${id}`
        )
        const data = await db()
        const product = data.products.find(
          (product) => product.id === Number(id) // We need to convert the id to a number because it's a string in the URL, but a number in the JSON data.
        )
        if (!product) {
          return Nope(id)
        }
        document.title = product.name // Set the page title to the product name
        search.value = product.name // Set the search input value to the product name
        product ? render(ProductComponent(product)) : Nope(id) // If we find a product, render it. If not, render the 404 page.
        if (product) {
          let button = document.querySelector(".add-to-cart")
          if (button.alreadyHasEventListener) return
          button.addEventListener("click", (e) => {
            addToCart(product)
          })
          button.alreadyHasEventListener = true
        }
      }

      const Cart = async () => {
        console.log("Cart Component is rendering")
        const cart = JSON.parse(localStorage.getItem("cart")) || {} // Get the cart from localStorage, or set it to an empty object if it doesn't exist.
        const data = await db()
        const products = data.products
        if (Object.keys(cart).length === 0) {
          // If the cart is empty, render a message saying so.
          render(`
          <h1>Cart</h1>
          <p>Your cart is empty. Go buy one of our two amazing items!</p>
          `)
        } else {
          // If the cart isn't empty, render the cart items.
          const cartItems = Object.keys(cart).map((id) => {
            const product = products.find(
              (product) => product.id === Number(id)
            )
            return `
            <div class="cart-item">
              <img src="${product.image}" alt="${product.name}" />
              <h2>${product.name}</h2>
              <p>$${product.price}</p>
              <p>Quantity: ${cart[id].quantity}</p>
              <button class="remove-from-cart" id="${product.id}">Remove from cart</button>
            </div>
            `
          })
          render(`
          <h1>Cart</h1>
          ${cartItems.join("")}
          `)
          document.querySelectorAll(".remove-from-cart").forEach((button) => {
            button.addEventListener("click", (e) => {
              const id = e.target.id
              product = products.find((product) => product.id === Number(id))
              removeFromCart(product)
            })
          })
        }
      }

      const Nope = (id) => {
        console.log(`404 Component just rendered on ${path}.`)
        console.log(`ID detected: ${!!id}`) // The double bang is just a fancy way of converting the id to a boolean. If there's an id, it'll be true. If there isn't, it'll be false.
        if (id) {
          render(
            `<h1>404</h1><h2>Sorry buddy, but I don't think we have a product with id #${id}!</h2>`
          )
        } else {
          render(`<div>
          <h1>404</h1>
          <h2>Huh, you're at ${path}, but you really shouldn't be</h2>
        </div>`)
        }
      } // Only on v1 of this project, and I already have 2 404 pages... I think that's a good sign?

      // Now lets define our routes. We're just going to do an array of objects, where each object has a path and a component. We'll loop over the array and render only the component whose path matches what is currently in the address bar.
      const Routes = [
        { path: "/", component: Home },
        { path: "/about", component: About },
        { path: "/products", component: ProductsPage },
        { path: "/product/", component: ProductPage },
        { path: "/cart", component: Cart },
      ]

      // The engine of the whole machine. This function will run every time the path in the address bar changes, which is prompted by the event listeners we add to links every time we render a component. A beautiful cycle.
      const Router = (whatIsInAddressBar) => {
        if (
          whatIsInAddressBar.split("/")[1] === dynamicRoute && // We're turning the path into an array by splitting it every time we see a slash. Then we're checking to see if the second item in the array is the same as the dynamicRoute global variable we set at the top of the file.
          whatIsInAddressBar.split("/")[2]
        ) {
          console.log("Dynamic route detected")
          const id = whatIsInAddressBar.split("/")[2] // If it is, we're getting the id from the third item in the array. This limits us to only having one dynamic route and only at that point in the array, but we're just showing one way to do it here. This would much more capable and flexible if we were to use regex, but I refuse.
          return ProductPage(id)
        } else {
          console.log("Static route detected")
          const route = Routes.find(
            (route) => route.path === whatIsInAddressBar
          )
          route ? route.component() : Nope()
        }
      }

      // Our reactive search. This function will run every time the user types in the search bar. It will filter the products based on what the user types, and then re-render the page with the filtered products.
      async function searchHandler() {
        const searchValue = search.value // Our search input is a global variable, so we can just grab the value from it.
        console.log(`Searching for ${searchValue}`)
        const data = await db()
        const products = data.products
        const filteredProducts = products.filter((product) => {
          return product.name.toLowerCase().includes(searchValue.toLowerCase()) // We're converting both the product name and the search value to lowercase so that we can search for "shirt" and "Shirt" and "SHIRT" and "sHiRt" and it will still work.
        })
        if (filteredProducts.length === 0) {
          render(`<h1>Products</h1><p>No products found!</p>`) // A third 404 page! I'm on a roll!
        } else {
          const productsHTML = filteredProducts.map(ProductComponent).join("")
          render(`<h1>Products</h1>${productsHTML}`)
          document.querySelectorAll(".add-to-cart").forEach((button) => {
            button.addEventListener("click", (e) => {
              const id = e.target.id
              const product = products.find(
                (product) => product.id === Number(id)
              )
              addToCart(product) // You know the drill by now.
            })
          })
        }
      }

      // This function will run every time the user clicks the "Add to cart" button. It will add the product to the cart in localStorage, or increase the quantity if it's already in the cart.
      function addToCart(product) {
        console.log(`Added ${product.name} to cart`)
        if (cart[product.id]) {
          // If the product is already in the cart, increment the quantity.
          cart[product.id].quantity++
        } else {
          // If the product isn't in the cart, add it and add a quantity property. (Notice how this doesn't conflict with the quantity property that's already on the product object. This is because we're adding the quantity property to the cart object, not the product object.)
          cart[product.id] = {
            quantity: 1,
            product,
          }
        }
        localStorage.setItem("cart", JSON.stringify(cart)) // Set the cart in localStorage to the updated cart.
        alert(`${product.name} added to cart!`) // Alert the user that the product was added to the cart.
        cartCount.innerText = Object.keys(cart).length // Update the cart count.
        cartAmount.innerText =
          "$" +
          Object.values(cart).reduce((acc, item) => {
            return acc + item.product.price * item.quantity
          }, 0) // Update the cart amount.
      }

      // This function will run every time the user clicks the "Remove from cart" button. It will remove the product from the cart in localStorage, or decrease the quantity if it's already in the cart.
      function removeFromCart(product) {
        console.log(`Removed ${product.name} from cart`)
        const cart = JSON.parse(localStorage.getItem("cart")) || {} // Get the cart from localStorage, or set it to an empty array if it doesn't exist.
        if (cart[product.id]) {
          // If the product is in the cart, decrement the quantity.
          cart[product.id].quantity--
        }
        if (cart[product.id].quantity === 0) {
          // If the quantity is 0, remove the product from the cart.
          delete cart[product.id]
        }
        localStorage.setItem("cart", JSON.stringify(cart)) // Set the cart in localStorage to the updated cart.
        alert(`${product.name} removed from cart!`) // Alert the user that the product was removed from the cart.
        Cart() // Re-render the cart.
        cartCount.innerText = Object.keys(cart).length // Update the cart count.
        cartAmount.innerText =
          "$" +
          Object.values(cart)
            .map((item) => item.product.price * item.quantity)
            .reduce((a, b) => a + b, 0)
            .toFixed(2) // Update the cart amount.
      }

      // Essential to any routed SPA, our linkFinder function will run every time we render a component. It will find all the links in the component, and add event listeners to them. When the user clicks a link, it will prevent the default behavior of the link (which is to navigate to a new page), and instead run the Router function with the path of the link as the argument.
      function linkFinder() {
        const links = document.querySelectorAll(".Link") // instead of targeting every anchor tag, we only target the ones meant for navigating around our app.
        links.forEach((link) => {
          if (link.alreadyHasEventListener) return // This is so that we don't add multiple event listeners to the same link.
          link.alreadyHasEventListener = true
          console.log(`Changing link behavior of ${link}`)
          // Target each link that we have marked with the Link class,
          link.addEventListener("click", (e) => {
            // add a click event listener
            e.preventDefault() // prevent the default behavior of the anchor tag (opening a new page)
            const linkPath = link.getAttribute("href") // get the href attribute of the link (the path)
            history.pushState(null, null, linkPath) // push the link's path to the history object
            Router(linkPath) // call the Router function with the link's path
          }) // Ta-da! We have a SPA! Oh, wait. We need to call the Router function once to render the initial page.
        })
      }

      // This function will run every time the user clicks the toggleTheme button. It will change the theme of the app.
      const toggleTheme = document.querySelector("#toggleTheme") // Get the toggleTheme button

      toggleTheme.addEventListener("click", () => {
        // Check current theme
        const currentTheme = localStorage.getItem("theme") || "dark" // Get the current theme from localStorage, or set it to dark if it doesn't exist.
        const newTheme =
          currentTheme === "dark"
            ? "purple"
            : "green"
            ? currentTheme === "purple"
              ? "green"
              : "dark"
            : "dark"
        document.body.className = newTheme
        localStorage.setItem("theme", newTheme) // Set the theme in localStorage to the new theme.
      })

      // Even more essential is the render function, which sets our reactive element's innerHTML to whatever we pass to it.
      async function render(component) {
        console.log(`The render function just ran with ${component}`)
        main.innerHTML = component // Since we only have one dynamic element on the page and very little state, this function is pretty simple.
        await linkFinder()
      }

      // Finally, we call the Router function with whatever the current path is. This will render the initial page.
      Router(path)

      // And, double finally, we add an event listener to the window object that waits until it is fully loaded, and then adds an event listener to the back and forward buttons. When the user clicks the back or forward button, it will run the Router function with the path of the new page as the argument. We have to do this because the Router function only runs when the user clicks a link, and we need it to run when the user clicks the back or forward button (remember, the back and forward buttons don't actually change the URL, they just change the history object and the popstate event is slow to fire).
      window.addEventListener("load", () => {
        window.addEventListener("popstate", () => {
          console.log(
            "A popstate event just fired, so the Router function is running again."
          )
          Router(window.location.pathname) // call the Router function with the current path to render the correct View. I couldn't use the global path variable here because it's not updated until after the Router function is called... I think. I don't know. It works.
        })
      })

      console.log("Script fully loaded into the DOM")
    </script>
  </body>
</html>
